
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Piano Power! ‚Äî Learn Piano</title>
  
  <!-- Favicon and app icons -->
  <link rel="icon" type="image/png" sizes="32x32" href="pianopower.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="pianopower.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="pianopower.png" />
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#ff6b6b" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;500;600;700&display=swap');
    
    :root { 
      --ink:#1e1b4b; 
      --panel:#ffffffcc; 
      --shadow: 0 10px 30px rgba(0,0,0,.08);
      --fun-font: 'Fredoka', 'Comic Sans MS', cursive;
      --big-button: #ff6b6b;
      --big-button-hover: #ff5252;
      --small-button: #4f46e5;
    }
    
    body { 
      margin:0; 
      font-family: var(--fun-font); 
      background: linear-gradient(135deg,#e0f2fe,#e9d5ff,#fef3c7); 
      color:var(--ink);
      min-height: 100vh;
    }
    
    .wrap { max-width: 1040px; margin: 0 auto; padding: 24px; }
    .card { background: var(--panel); border: 1px solid #e5e7eb; border-radius: 20px; padding: 16px; box-shadow: var(--shadow); }
    
    /* Big fun buttons for song selection */
    .big-btn { 
      background: var(--big-button); 
      color: #fff; 
      border: none; 
      border-radius: 20px; 
      padding: 24px 32px; 
      font-size: 24px; 
      font-weight: 700; 
      font-family: var(--fun-font);
      cursor: pointer; 
      min-height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 8px 20px rgba(255, 107, 107, 0.3);
    }
    .big-btn:hover { 
      background: var(--big-button-hover); 
      transform: translateY(-2px);
      box-shadow: 0 12px 30px rgba(255, 107, 107, 0.4);
    }
    
    /* Regular buttons */
    .btn { 
      background: var(--small-button); 
      color: #fff; 
      border: none; 
      border-radius: 14px; 
      padding: 12px 16px; 
      font-weight: 700; 
      font-family: var(--fun-font);
      cursor: pointer; 
    }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    
    /* Small pills for options */
    .pill { 
      display: inline-block; 
      padding: 8px 16px; 
      border-radius: 999px; 
      border: 2px solid #e5e7eb; 
      background: #fff; 
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      font-family: var(--fun-font);
      transition: all 0.2s ease;
    }
    .pill.active { 
      border-color: var(--small-button);
      background: var(--small-button);
      color: white;
    }
    .pill:hover { transform: translateY(-1px); }
    
    /* Layout helpers */
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .grid2 { display:grid; grid-template-columns: repeat(auto-fit, minmax(260px,1fr)); gap:12px; }
    .center { text-align: center; }
    .top-options { margin-bottom: 32px; padding: 16px; background: rgba(255,255,255,0.7); border-radius: 16px; }
    .song-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 32px 0; }
    
    /* Typography improvements */
    h1 { font-size: 48px; margin: 0; font-weight: 700; color: var(--big-button); text-shadow: 2px 2px 4px rgba(0,0,0,0.1); }
    h2 { font-size: 36px; margin-top: 0; font-weight: 600; color: var(--ink); }
    h3 { font-size: 20px; margin-top: 16px; font-weight: 600; color: var(--ink); }
    
    /* Page-specific styles */
    .welcome-page { text-align: center; min-height: 60vh; display: flex; flex-direction: column; justify-content: center; }
    .name-input { 
      font-size: 20px; 
      padding: 16px 24px; 
      border-radius: 16px; 
      border: 3px solid #e5e7eb;
      font-family: var(--fun-font);
      margin: 20px 0;
      max-width: 300px;
    }
    .name-input:focus { border-color: var(--big-button); outline: none; }
    
    /* Existing game styles */
    .kbd { user-select:none; position:relative; display:flex; gap:4px; padding:8px; border-radius:18px; border:1px solid #e5e7eb; background:#ffffffcf; box-shadow: inset 0 6px 14px rgba(0,0,0,.05); max-width: calc(100% - 16px); margin: 0 auto; }
    .white { position:relative; flex:1 1 0; height:120px; min-width:40px; border-radius:12px; background:#fff; border:1px solid #e5e7eb; box-shadow: inset 0 -2px 0 #e5e7eb; }
    .white .lbl { position:absolute; bottom:6px; width:100%; text-align:center; font-size:12px; font-weight:700; }
    .black { position:absolute; width:28px; height:70px; background:#1f2937; border:1px solid #111827; border-radius:0 0 8px 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index:2; }
    .black .lbl { position:absolute; bottom:6px; width:100%; text-align:center; font-size:10px; font-weight:700; color:#fff; }
    .timeline { height:72px; border-radius:16px; background:#ffffffcf; border:1px solid #e5e7eb; padding:8px; display:flex; gap:8px; overflow:hidden; }
    .noteBlock { min-width:12%; border-radius:12px; display:flex; align-items:center; justify-content:center; color:#fff; font-weight:800; box-shadow: var(--shadow); }
    /* Enhanced star animation with platform jumping */
    .scene { 
      position:relative; 
      height:240px; 
      border-radius:20px; 
      overflow:hidden; 
      background: linear-gradient(180deg,#0b102d,#1e3a8a); 
      box-shadow: inset 0 -40px 80px rgba(0,0,0,.3);
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }
    .scene.mary-background {
      background-image: url('mary background.png');
      background-position: center center; /* Move background down to show grass */
    }
    .scene.twinkle-background {
      background-image: url('images/twinkle background.png');
    }
    .scene.letitgo-background {
      background-image: url('letitgo_background.png');
    }
    
    /* New song backgrounds */
    .scene.oldmacdonald-background {
      background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 70%, #228B22 100%);
    }
    .scene.wheelsonbus-background {
      background: linear-gradient(to bottom, #87CEEB 0%, #C0C0C0 70%, #696969 100%);
    }
    .scene.babyshark-background {
      background: linear-gradient(to bottom, #00BFFF 0%, #1E90FF 50%, #0000CD 100%);
    }
    .scene.humptydumpty-background {
      background: linear-gradient(to bottom, #87CEEB 0%, #F0E68C 70%, #32CD32 100%);
    }
    .scene.baablacksheep-background {
      background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 70%, #228B22 100%);
    }
    .scene.itsyspider-background {
      background: linear-gradient(to bottom, #87CEEB 0%, #DDD 50%, #8B4513 100%);
    }
    .scene.rowboat-background {
      background: linear-gradient(to bottom, #87CEEB 0%, #4682B4 50%, #191970 100%);
    }
    /* For uploaded songs: smaller scene, bigger keyboard */
    .uploaded-layout .scene {
      height: 120px; /* Reduced from 240px */
    }
    .uploaded-layout .kbd {
      padding: 20px; /* Increased from 10px */
    }
    .uploaded-layout .white {
      height: 140px; /* Increased from 120px */
      min-width: 50px; /* Increased from 44px */
    }
    /* Characters have higher z-index */
    .star, .lamb, .mary, .elsa, .farmer, .bus, .shark, .humpty, .blacksheep, .spider, .boat { z-index: 10; }
    .star { 
      position:absolute; 
      left:50%; 
      transform:translateX(-50%); 
      width:60px; 
      height:60px;
      transition: transform .6s cubic-bezier(.68,-0.55,.265,1.55); 
      z-index: 10;
    }
    
    .star-effect {
      position:absolute; 
      left:50%; 
      transform:translateX(-50%); 
      width:120px; 
      height:30px;
      transition: opacity 0.5s ease-in-out; 
      z-index: 11;
      top: -20px; /* Position at top of scene */
    }
    
    /* Custom lamb animation for Mary's song - using CSS animation instead of PNG sprite */
    .lamb {
      position: absolute;
      bottom: 0px;
      left: 0;
      width: 48px;
      height: 48px;
      transition: left 0.6s cubic-bezier(.68,-0.55,.265,1.55);
      z-index: 10;
      background: #FFF;
      border-radius: 50%;
      border: 2px solid #333;
    }
    
    .lamb::before {
      content: 'üêë';
      position: absolute;
      font-size: 32px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    /* New character animations */
    .farmer {
      position: absolute;
      bottom: 10px;
      left: 0;
      width: 60px;
      height: 40px;
      transition: left 0.6s cubic-bezier(.68,-0.55,.265,1.55);
      z-index: 10;
      background: #8B4513;
      border-radius: 8px;
    }
    
    .farmer::before {
      content: 'üöú';
      position: absolute;
      font-size: 32px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    .bus {
      position: absolute;
      bottom: 20px;
      left: 0;
      width: 80px;
      height: 50px;
      transition: left 0.6s cubic-bezier(.68,-0.55,.265,1.55);
      z-index: 10;
      background: #FFD700;
      border-radius: 12px;
      border: 2px solid #333;
    }
    
    .bus::before {
      content: 'üöå';
      position: absolute;
      font-size: 40px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    .shark {
      position: absolute;
      bottom: 60px;
      left: 0;
      width: 60px;
      height: 40px;
      transition: left 0.6s cubic-bezier(.68,-0.55,.265,1.55);
      z-index: 10;
    }
    
    .shark::before {
      content: 'ü¶à';
      position: absolute;
      font-size: 36px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    .humpty {
      position: absolute;
      bottom: 80px;
      left: 20px;
      width: 50px;
      height: 60px;
      transition: all 0.6s cubic-bezier(.68,-0.55,.265,1.55);
      z-index: 10;
    }
    
    .humpty::before {
      content: 'ü•ö';
      position: absolute;
      font-size: 40px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    .blacksheep {
      position: absolute;
      bottom: 10px;
      left: 0;
      width: 50px;
      height: 50px;
      transition: left 0.6s cubic-bezier(.68,-0.55,.265,1.55);
      z-index: 10;
    }
    
    .blacksheep::before {
      content: 'üêë';
      position: absolute;
      font-size: 36px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      filter: brightness(0.3);
    }
    
    .spider {
      position: absolute;
      bottom: 0px;
      left: 20px;
      width: 40px;
      height: 40px;
      transition: all 0.6s cubic-bezier(.68,-0.55,.265,1.55);
      z-index: 10;
    }
    
    .spider::before {
      content: 'üï∑Ô∏è';
      position: absolute;
      font-size: 28px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    .boat {
      position: absolute;
      bottom: 40px;
      left: 0;
      width: 60px;
      height: 40px;
      transition: left 0.6s cubic-bezier(.68,-0.55,.265,1.55);
      z-index: 10;
    }
    
    .boat::before {
      content: 'üö£';
      position: absolute;
      font-size: 32px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    /* Mary character at the end - PNG image */
    .mary {
      position: absolute;
      bottom: 14px; /* Position on ground level */
      right: 20px;
      width: 192px; /* Made 3X larger (was 64px) */
      height: 192px;
      z-index: 10;
      image-rendering: pixelated; /* Keep pixel art crisp */
    }
    
    /* Elsa character for Let it Go song */
    .elsa {
      position: absolute;
      bottom: 30px; /* Position on snow ground */
      left: 0;
      width: 64px;
      height: 64px;
      transition: left 0.6s cubic-bezier(.68,-0.55,.265,1.55);
      z-index: 10;
      image-rendering: pixelated; /* Keep pixel art crisp */
    }
    
    /* Enhanced platform jumping animation */
    @keyframes starJump {
      0% { transform: translateX(-50%) translateY(0px) scale(1) rotate(0deg); }
      15% { transform: translateX(-50%) translateY(-10px) scale(1.1) rotate(-5deg); }
      30% { transform: translateX(-50%) translateY(0px) scale(1) rotate(0deg); }
      100% { transform: translateX(-50%) translateY(0px) scale(1) rotate(0deg); }
    }
    
    .star.jumping { animation: starJump 0.6s cubic-bezier(.68,-0.55,.265,1.55); }
    
    @keyframes twinkle { 
      0%,100%{opacity:1; filter: brightness(1) drop-shadow(0 0 10px #ffd26a);} 
      50%{opacity:.7; filter: brightness(1.3) drop-shadow(0 0 20px #f59e0b);} 
    }
    .twinkle { animation: twinkle 1.2s ease-in-out infinite; }
    
    @keyframes finalCelebration {
      0% { transform: translateX(-50%) scale(.4) rotate(0deg); filter: brightness(1); }
      25% { transform: translateX(-50%) scale(.5) rotate(90deg); filter: brightness(1.2); }
      50% { transform: translateX(-50%) scale(.4) rotate(180deg); filter: brightness(1.4); }
      75% { transform: translateX(-50%) scale(.5) rotate(270deg); filter: brightness(1.2); }
      100% { transform: translateX(-50%) scale(.4) rotate(360deg); filter: brightness(1); }
    }
    
    .small { 
      transform: translateX(-50%) scale(.4) translateY(-150px) !important; 
      animation: finalCelebration 2s ease-in-out infinite;
    }
    
    /* Completion popup modal - Enhanced */
    .completion-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .completion-popup {
      background: white;
      border-radius: 24px;
      padding: 40px;
      text-align: center;
      max-width: 500px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      animation: popupAppear 0.5s cubic-bezier(.68,-0.55,.265,1.55);
    }
    
    @keyframes popupAppear {
      0% { transform: scale(0.5) translateY(50px); opacity: 0; }
      100% { transform: scale(1) translateY(0); opacity: 1; }
    }
    
    .completion-popup h2 {
      color: var(--big-button);
      margin-bottom: 20px;
      font-size: 36px;
      font-family: var(--fun-font);
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    
    .completion-popup .time-display {
      font-size: 48px;
      font-weight: 800;
      color: #7c3aed;
      margin: 20px 0;
      font-family: var(--fun-font);
      text-shadow: 2px 2px 4px rgba(124, 58, 237, 0.3);
    }
    
    .completion-popup .comparison-graph {
      margin: 30px 0;
      padding: 20px;
      background: #f8fafc;
      border-radius: 16px;
      border: 2px solid #e2e8f0;
    }
    
    .graph-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 16px;
      color: var(--ink);
    }
    
    .graph-bar {
      display: flex;
      align-items: center;
      margin: 12px 0;
      position: relative;
    }
    
    .graph-label {
      width: 100px;
      text-align: left;
      font-weight: 600;
      font-size: 14px;
    }
    
    .graph-bar-container {
      flex: 1;
      height: 24px;
      background: #e2e8f0;
      border-radius: 12px;
      overflow: hidden;
      margin: 0 12px;
      position: relative;
    }
    
    .graph-bar-fill {
      height: 100%;
      border-radius: 12px;
      transition: width 0.8s ease-out;
      position: relative;
    }
    
    .target-bar { background: #10b981; }
    .user-bar { background: #3b82f6; }
    .user-bar.better { background: #f59e0b; }
    .user-bar.excellent { background: #8b5cf6; }
    
    .graph-time {
      font-weight: 700;
      font-size: 12px;
      min-width: 40px;
      text-align: right;
    }
    
    .celebration {
      margin: 20px 0;
      font-size: 24px;
      animation: bounce 1s ease-in-out infinite;
    }
    
    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-10px); }
      60% { transform: translateY(-5px); }
    }
    
    @keyframes confetti {
      0% { transform: rotate(0deg) scale(1); opacity: 1; }
      100% { transform: rotate(720deg) scale(0); opacity: 0; }
    }
    
    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #ff6b6b;
      animation: confetti 2s ease-out forwards;
    }
    
    .completion-popup .button-row {
      display: flex;
      gap: 16px;
      justify-content: center;
      margin-top: 30px;
    }
    
    .feedback { text-align:center; font-weight:700; }
    .muted { color:#4338ca; opacity:.85; }
    .hidden { display:none; }
    .select, select, input[type="text"]{ padding:10px; border-radius:12px; border:1px solid #e5e7eb }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Page 1: Welcome & Name -->
    <section id="welcome" class="welcome-page">
      <h1>üéπ Piano Power!</h1>
      <h2>Hello! Time to learn Piano.</h2>
      <h2>What's your name?</h2>
      <div class="center">
        <input id="name" class="name-input" placeholder="Your name" maxlength="20" />
        <br>
        <button id="nextToSongs" class="big-btn" style="margin: 24px auto 0; display: block;">Let's Go! üöÄ</button>
      </div>
    </section>

    <!-- Page 2: Song Selection -->
    <section id="songSelection" class="hidden">
      <h1 class="center">üéπ Piano Power!</h1>
      
      <!-- Small options at top -->
      <div class="top-options">
        <div class="row" style="justify-content: space-between; align-items: center;">
          <div>
            <span style="font-weight: 600; margin-right: 12px;">Input:</span>
            <button class="pill active" id="modeMIDI">üéπ MIDI Keyboard</button>
          </div>
          <div>
            <span style="font-weight: 600; margin-right: 12px;">Audio:</span>
            <button class="pill active" id="audioOn">üîä On</button>
          </div>
          <div>
            <span style="font-weight: 600; margin-right: 12px;">Difficulty:</span>
            <button class="pill active" id="easyMode">Easy</button>
            <button class="pill" id="mediumMode">Medium</button>
            <button class="pill" id="strictMode">Strict</button>
          </div>
        </div>
      </div>

      <!-- Big song choice buttons -->
      <div class="center">
        <h2>Choose Your Song! üéµ</h2>
        
        <!-- Easy versions -->
        <h3 style="margin: 24px 0 16px 0; color: #22c55e;">üåü Easy Versions</h3>
        <div class="song-grid">
          <button class="big-btn" id="chooseTwinkleEasy" style="background: #22c55e; box-shadow: 0 8px 20px rgba(34, 197, 94, 0.3);">
            ‚≠ê Twinkle Twinkle (Easy)
          </button>
          <button class="big-btn" id="chooseMaryEasy" style="background: #22c55e; box-shadow: 0 8px 20px rgba(34, 197, 94, 0.3);">
            üêë Mary Had a Little Lamb (Easy)
          </button>
          <button class="big-btn" id="chooseOldMacdonaldEasy" style="background: #22c55e; box-shadow: 0 8px 20px rgba(34, 197, 94, 0.3);">
            üöú Old MacDonald (Easy)
          </button>
          <button class="big-btn" id="chooseWheelsOnBusEasy" style="background: #22c55e; box-shadow: 0 8px 20px rgba(34, 197, 94, 0.3);">
            üöå Wheels on the Bus (Easy)
          </button>
          <button class="big-btn" id="chooseBabySharkEasy" style="background: #22c55e; box-shadow: 0 8px 20px rgba(34, 197, 94, 0.3);">
            ü¶à Baby Shark (Easy)
          </button>
          <button class="big-btn" id="chooseHumptyDumptyEasy" style="background: #22c55e; box-shadow: 0 8px 20px rgba(34, 197, 94, 0.3);">
            ü•ö Humpty Dumpty (Easy)
          </button>
          <button class="big-btn" id="chooseBaaBlackSheepEasy" style="background: #22c55e; box-shadow: 0 8px 20px rgba(34, 197, 94, 0.3);">
            üêë Baa Baa Black Sheep (Easy)
          </button>
          <button class="big-btn" id="chooseItsySpiderEasy" style="background: #22c55e; box-shadow: 0 8px 20px rgba(34, 197, 94, 0.3);">
            üï∑Ô∏è Itsy Bitsy Spider (Easy)
          </button>
          <button class="big-btn" id="chooseRowBoatEasy" style="background: #22c55e; box-shadow: 0 8px 20px rgba(34, 197, 94, 0.3);">
            üö£ Row Your Boat (Easy)
          </button>
        </div>
        
        <!-- Full versions -->
        <h3 style="margin: 32px 0 16px 0; color: var(--big-button);">üéº Full Versions</h3>
        <div class="song-grid">
          <button class="big-btn" id="chooseTwinkle">
            ‚≠ê Twinkle Twinkle Little Star
          </button>
          <button class="big-btn" id="chooseMary">
            üêë Mary Had a Little Lamb  
          </button>
          <button class="big-btn" id="chooseOldMacdonald">
            üöú Old MacDonald Had a Farm
          </button>
          <button class="big-btn" id="chooseWheelsOnBus">
            üöå The Wheels on the Bus
          </button>
          <button class="big-btn" id="chooseBabyShark">
            ü¶à Baby Shark
          </button>
          <button class="big-btn" id="chooseHumptyDumpty">
            ü•ö Humpty Dumpty
          </button>
          <button class="big-btn" id="chooseBaaBlackSheep">
            üêë Baa Baa Black Sheep
          </button>
          <button class="big-btn" id="chooseItsySpider">
            üï∑Ô∏è Itsy Bitsy Spider
          </button>
          <button class="big-btn" id="chooseRowBoat">
            üö£ Row Row Row Your Boat
          </button>
        </div>
        
        <!-- Harder versions -->
        <h3 style="margin: 32px 0 16px 0; color: #7c3aed;">‚ùÑÔ∏è Harder Versions</h3>
        <div class="song-grid">
          <button class="big-btn" id="chooseLetItGo" style="background: #7c3aed; box-shadow: 0 8px 20px rgba(124, 58, 237, 0.3);">
            ‚ùÑÔ∏è Let it Go
          </button>
        </div>
        
        <div style="margin-top: 32px;">
          <h3>Or upload your own MIDI file:</h3>
          <input type="file" id="file" accept=".mid,.midi" style="margin: 16px 0;" />
          <button id="startWithUpload" class="btn" style="margin-left: 12px;">Play Uploaded Song</button>
        </div>
      </div>
      
      <div class="center" style="margin-top: 32px;">
        <button id="backToWelcome" class="btn">‚Üê Back</button>
      </div>
    </section>

    <!-- Page 3: Game Interface -->
    <section id="play" class="hidden">
      <div class="row" style="justify-content:space-between;margin-bottom:8px">
        <div><b id="songTitle">Twinkle Twinkle Little Star</b></div>
        <button class="pill" id="back">‚Üê Back to Songs</button>
      </div>

      <div class="scene" id="scene">
        
        <!-- Star for other songs (now using PNG) -->
        <img class="star" id="star" src="images/star.png" style="display: block;" />
        
        <!-- Star effect for Twinkle ending -->
        <img class="star-effect" id="starEffect" src="images/stareffect.png" style="display: none;" />
        
        <!-- Lamb for Mary Had a Little Lamb (now using CSS animation) -->
        <div class="lamb" id="lamb" style="display: none;"></div>
        
        <!-- Elsa character for Let it Go song -->
        <img class="elsa" id="elsa" src="elsa.png" style="display: none;" />
        
        <!-- New animated characters -->
        <div class="farmer" id="farmer" style="display: none;"></div>
        <div class="bus" id="bus" style="display: none;"></div>
        <div class="shark" id="shark" style="display: none;"></div>
        <div class="humpty" id="humpty" style="display: none;"></div>
        <div class="blacksheep" id="blacksheep" style="display: none;"></div>
        <div class="spider" id="spider" style="display: none;"></div>
        <div class="boat" id="boat" style="display: none;"></div>
      </div>

      <div class="timeline" id="timeline"></div>

      <div class="card" style="margin-top:12px">
        <div class="row" style="justify-content:space-between">
          <div>Input: <b id="modeLbl">Microphone</b></div>
          <div>Time: <b id="time">0s</b> | Best: <b id="best">‚Äî</b> | Last: <b id="last">‚Äî</b></div>
        </div>
        <div style="margin:8px 0;font-weight:800" id="prompt">Press: C (Red)</div>
        <div class="kbd" id="kbd"></div>
        <div class="feedback muted" id="feedback"></div>
      </div>
    </section>

    <footer style="margin-top:16px" class="muted center">
      Made with ‚ù§Ô∏è for young pianists! No data is stored after reload.
    </footer>
  </div>

  <!-- Completion Modal -->
  <div id="completionModal" class="completion-modal hidden">
    <div class="completion-popup">
      <h2>üéâ Well Done!</h2>
      <p class="time-display" id="completionTimeDisplay">0s</p>
      <div class="comparison-graph" id="comparisonGraph">
        <div class="graph-title">Performance Comparison</div>
        <div class="graph-bar">
          <div class="graph-label">Target:</div>
          <div class="graph-bar-container">
            <div class="graph-bar-fill target-bar" id="targetBar"></div>
          </div>
          <div class="graph-time" id="targetTime">8s</div>
        </div>
        <div class="graph-bar">
          <div class="graph-label">Your time:</div>
          <div class="graph-bar-container">
            <div class="graph-bar-fill user-bar" id="userBar"></div>
          </div>
          <div class="graph-time" id="userTime">0s</div>
        </div>
      </div>
      <div id="celebrationMessage" class="celebration"></div>
      <p style="font-size: 16px; color: #6b7280;">Try again?</p>
      <div class="button-row">
        <button id="tryAgainBtn" class="big-btn" style="font-size: 18px; padding: 16px 24px; min-height: auto;">üîÑ Try Again</button>
        <button id="backToMenuBtn" class="btn" style="font-size: 16px; padding: 12px 20px;">‚Üê Back to Menu</button>
      </div>
    </div>
  </div>

<script>
// --------- Config ---------
const COLORS = { C:'#ef4444', D:'#f97316', E:'#facc15', F:'#22c55e', G:'#7dd3fc', A:'#1d4ed8', B:'#a855f7' };
const COLOR_NAME = { C:'Red', D:'Orange', E:'Yellow', F:'Green', G:'Light Blue', A:'Navy Blue', B:'Purple' };
const WHITE = ['C','D','E','F','G','A','B'];
const BLACK = ['C#','D#','F#','G#','A#'];
const STEPS = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const C4 = 60; // middle C

// Built-in songs - extracted from MIDI files
const SONGS = {
  twinkle: {
    title: 'Twinkle Twinkle Little Star',
    notes: ['C4','C4','G4','G4','A4','A4','G4','F4','F4','E4','E4','D4','D4','C4'],
    midiFile: 'midi/twinkle-twinkle-little-star.mid'
  },
  mary: {
    title: 'Mary Had a Little Lamb', 
    notes: ['E4','D4','C4','D4','E4','E4','E4','D4','D4','D4','E4','G4','G4'],
    midiFile: 'midi/mary-had-a-little-lamb.mid'
  },
  letitgo: {
    title: 'Let it Go',
    notes: ['F4','G4','A4','Bb4','C5','D5','Eb5','F5'], // Placeholder notes
    midiFile: 'midi/letitgo.mid'
  },
  twinkleEasy: {
    title: 'Twinkle Twinkle Little Star (Easy)',
    notes: ['C4','C4','G4','G4','A4','A4','G4','F4','F4','E4','E4','D4','D4','C4'],
    // No midiFile - uses only hardcoded notes (fallback = normal version)
  },
  maryEasy: {
    title: 'Mary Had a Little Lamb (Easy)', 
    notes: ['E4','D4','C4','D4','E4','E4','E4','D4','D4','D4','E4','G4','G4'],
    // No midiFile - uses only hardcoded notes (fallback = normal version)
  },
  
  // New Easy Songs
  oldMacdonaldEasy: {
    title: 'Old MacDonald Had a Farm (Easy)',
    notes: ['G4','G4','G4','D4','E4','E4','D4','B4','B4','A4','A4','G4']
  },
  oldMacdonald: {
    title: 'Old MacDonald Had a Farm',
    notes: ['G4','G4','G4','D4','E4','E4','D4','B4','B4','A4','A4','G4','D4','G4','G4','G4','D4','E4','E4','D4','B4','B4','A4','A4','G4','D4','D4','G4','G4','G4','D4','D4','G4','G4','G4','G4','G4','G4','G4','G4','G4','G4','G4','G4','D4','E4','E4','D4','B4','B4','A4','A4','G4']
  },
  
  wheelsOnBusEasy: {
    title: 'The Wheels on the Bus (Easy)',
    notes: ['C4','F4','F4','F4','F4','A4','C5','A4','F4','G4','C4','C4','F4']
  },
  wheelsOnBus: {
    title: 'The Wheels on the Bus',
    notes: ['C4','F4','F4','F4','F4','A4','C5','A4','F4','G4','E4','C4','A4','G4','F4','C4','F4','F4','F4','F4','A4','C5','A4','F4','G4','C4','C4','F4']
  },
  
  babySharkEasy: {
    title: 'Baby Shark (Easy)',
    notes: ['D4','E4','G4','G4','G4','G4','G4','G4','G4','D4','E4','G4','G4','G4','G4','G4','G4','G4','D4','E4','G4','G4','G4','G4','G4','G4','G4','G4','G4','F#4']
  },
  babyShark: {
    title: 'Baby Shark',
    notes: ['D4','E4','G4','G4','G4','G4','G4','G4','G4','D4','E4','G4','G4','G4','G4','G4','G4','G4','D4','E4','G4','G4','G4','G4','G4','G4','G4','G4','G4','F#4','D4','E4','G4','G4','G4','G4','G4','G4','G4','D4','E4','G4','G4','G4','G4','G4','G4','G4','D4','E4','G4','G4','G4','G4','G4','G4','G4','G4','G4','F#4','D4','E4','G4','G4','G4','G4','G4','G4','G4','D4','E4','G4','G4','G4','G4','G4','G4','G4','D4','E4','G4','G4','G4','G4','G4','G4','G4','G4','G4','F#4']
  },
  
  humptyDumptyEasy: {
    title: 'Humpty Dumpty (Easy)',
    notes: ['E4','G4','F4','A4','G4','A4','B4','C5','E4','G4','F4','A4','G4','E4','C4','D4','E4','E4','G4','F4','F4','G4','G4','A4','B4','C5','E5','E5','C5','F5','F5','E5','D5','C5','B4','C5']
  },
  humptyDumpty: {
    title: 'Humpty Dumpty',
    notes: ['E4','G4','F4','A4','G4','A4','B4','C5','E4','G4','F4','A4','G4','E4','C4','D4','E4','E4','G4','F4','F4','G4','G4','A4','B4','C5','E5','E5','C5','F5','F5','E5','D5','C5','B4','C5','E4','G4','F4','A4','G4','A4','B4','C5','E4','G4','F4','A4','G4','E4','C4','D4','E4','E4','G4','F4','F4','G4','G4','A4','B4','C5','E5','E5','C5','F5','F5','E5','D5','C5','B4','C5']
  },
  
  baaBlackSheepEasy: {
    title: 'Baa Baa Black Sheep (Easy)',
    notes: ['C4','C4','G4','G4','A4','A4','A4','A4','G4','F4','F4','E4','E4','D4','D4','C4']
  },
  baaBlackSheep: {
    title: 'Baa Baa Black Sheep',
    notes: ['C4','C4','G4','G4','A4','A4','A4','A4','G4','F4','F4','E4','E4','D4','D4','C4','G4','G4','G4','F4','F4','E4','E4','E4','D4','C4','G4','G4','G4','F4','F4','F4','F4','E4','E4','E4','D4']
  },
  
  itsySpiderEasy: {
    title: 'Itsy Bitsy Spider (Easy)',
    notes: ['G3','C4','C4','C4','D4','E4','E4','E4','D4','C4','D4','E4','C4']
  },
  itsySpider: {
    title: 'Itsy Bitsy Spider',
    notes: ['G3','C4','C4','C4','D4','E4','E4','E4','D4','C4','D4','E4','C4','E4','E4','F4','G4','G4','F4','E4','F4','G4','E4','C4','C4','D4','E4','E4','D4','C4','D4','E4','C4','G3','G3','C4','C4','C4','D4','E4','E4','E4','D4','C4','D4','E4','C4']
  },
  
  rowBoatEasy: {
    title: 'Row Row Row Your Boat (Easy)',
    notes: ['C4','C4','C4','D4','E4','E4','D4','E4','F4','G4','C5','C5','C5','G4','G4','G4','E4','E4','E4','C4','C4','C4','G4','F4','E4','D4','C4']
  },
  rowBoat: {
    title: 'Row Row Row Your Boat',
    notes: ['C4','C4','C4','D4','E4','E4','D4','E4','F4','G4','C5','C5','C5','G4','G4','G4','E4','E4','E4','C4','C4','C4','G4','F4','E4','D4','C4','C4','C4','C4','D4','E4','E4','D4','E4','F4','G4','C5','C5','C5','G4','G4','G4','E4','E4','E4','C4','C4','C4','G4','F4','E4','D4','C4','C4','C4','C4','D4','E4','E4','D4','E4','F4','G4','C5','C5','C5','G4','G4','G4','E4','E4','E4','C4','C4','C4','G4','F4','E4','D4','C4']
  },
};

// State (session only)
let state = {
  mode: 'midi',           // Force MIDI mode
  difficulty: 'easy',     // 'easy' | 'strict'
  audioEnabled: true,     // Force audio on at max
  name: '',
  queue: SONGS.twinkle.notes.map(toObj), // default
  idx: 0,
  finished: false,
  startTime: null,
  elapsed: 0,
  timerStarted: false,
  bestTimes: {},          // per-song best in this session
  lastTimes: {},          // per-song last in this session
  songKey: 'twinkle',
  strictOctaveRange: [3, 5], // Current 3-octave range for strict mode [low, high]
  expected() { return this.queue[this.idx] || null; },
};

// Helpers
const el = (id)=>document.getElementById(id);
function toObj(s){ // 'C#4' -> {step:'C#'|'Db', stepWhite:'C', octave:4}
  const m = s.match(/^([A-G]#?)(\d)$/); if(!m) return {step:'C', stepWhite:'C', octave:4};
  const step = m[1]; const octave = parseInt(m[2],10);
  const stepWhite = step.replace('#',''); // map to white for visuals
  return {step, stepWhite, octave};
}
function fromMidi(m){
  const step = STEPS[m%12]; const octave=Math.floor(m/12)-1;
  return {step, stepWhite: step.replace('#',''), octave};
}
function toLabel(n, strict){ return strict ? `${n.stepWhite}${n.octave}` : n.stepWhite; }
function sayWrong(){ return 'Sorry, wrong note'; }
function dir(target, got){ return got<target ? 'Try again but higher' : 'Try again lower'; }

// UI refs
const welcome = el('welcome');
const songSelection = el('songSelection');
const play = el('play');
const kbd = el('kbd');
const prompt = el('prompt');
const feedback = el('feedback');
const modeLbl = el('modeLbl');
const timeline = el('timeline');
const star = el('star');
const lamb = el('lamb');
const mary = el('mary');
const elsa = el('elsa');
const farmer = el('farmer');
const bus = el('bus');
const shark = el('shark');
const humpty = el('humpty');
const blacksheep = el('blacksheep');
const spider = el('spider');
const boat = el('boat');
const timeLbl = el('time');
const bestLbl = el('best');
const lastLbl = el('last');
const songTitleLbl = el('songTitle');
const completionModal = el('completionModal');
const completionTimeDisplay = el('completionTimeDisplay');
const tryAgainBtn = el('tryAgainBtn');
const backToMenuBtn = el('backToMenuBtn');

// Controls wiring - Updated for new page flow (MIDI only mode)
el('modeMIDI').onclick = (e)=>{ pick('mode','midi',['modeMIDI'],e)};
el('easyMode').onclick = (e)=>{ pick('difficulty','easy',['easyMode','mediumMode','strictMode'],e)};
el('mediumMode').onclick = (e)=>{ pick('difficulty','medium',['easyMode','mediumMode','strictMode'],e)};
el('strictMode').onclick = (e)=>{ pick('difficulty','strict',['easyMode','mediumMode','strictMode'],e)};
el('audioOn').onclick = (e)=>{ pick('audioEnabled',true,['audioOn'],e)};

// New page navigation
el('nextToSongs').onclick = async ()=>{ 
  state.name = el('name').value.trim(); 
  
  // Unlock audio context on user interaction for iOS/iPad
  if (!audioContextUnlocked) {
    await unlockAudioContext();
  }
  
  swap(welcome, songSelection); 
};
el('backToWelcome').onclick = ()=>{ swap(songSelection, welcome); };
el('chooseTwinkle').onclick = async ()=>{ await startGameWithSong('twinkle'); };
el('chooseMary').onclick = async ()=>{ await startGameWithSong('mary'); };
el('chooseLetItGo').onclick = async ()=>{ await startGameWithSong('letitgo'); };
el('chooseTwinkleEasy').onclick = async ()=>{ await startGameWithSong('twinkleEasy'); };
el('chooseMaryEasy').onclick = async ()=>{ await startGameWithSong('maryEasy'); };

// New Easy Song Handlers
el('chooseOldMacdonaldEasy').onclick = async ()=>{ await startGameWithSong('oldMacdonaldEasy'); };
el('chooseWheelsOnBusEasy').onclick = async ()=>{ await startGameWithSong('wheelsOnBusEasy'); };
el('chooseBabySharkEasy').onclick = async ()=>{ await startGameWithSong('babySharkEasy'); };
el('chooseHumptyDumptyEasy').onclick = async ()=>{ await startGameWithSong('humptyDumptyEasy'); };
el('chooseBaaBlackSheepEasy').onclick = async ()=>{ await startGameWithSong('baaBlackSheepEasy'); };
el('chooseItsySpiderEasy').onclick = async ()=>{ await startGameWithSong('itsySpiderEasy'); };
el('chooseRowBoatEasy').onclick = async ()=>{ await startGameWithSong('rowBoatEasy'); };

// New Full Song Handlers
el('chooseOldMacdonald').onclick = async ()=>{ await startGameWithSong('oldMacdonald'); };
el('chooseWheelsOnBus').onclick = async ()=>{ await startGameWithSong('wheelsOnBus'); };
el('chooseBabyShark').onclick = async ()=>{ await startGameWithSong('babyShark'); };
el('chooseHumptyDumpty').onclick = async ()=>{ await startGameWithSong('humptyDumpty'); };
el('chooseBaaBlackSheep').onclick = async ()=>{ await startGameWithSong('baaBlackSheep'); };
el('chooseItsySpider').onclick = async ()=>{ await startGameWithSong('itsySpider'); };
el('chooseRowBoat').onclick = async ()=>{ await startGameWithSong('rowBoat'); };
el('startWithUpload').onclick = async ()=>{ 
  const file = el('file').files[0];
  if(file) {
    onFile({target: {files: [file]}});
  } else {
    alert('Please select a MIDI file first!');
  }
};
el('back').onclick = ()=>{ stopInputs(); reset(); swap(play, songSelection); };
el('file').addEventListener('change', onFile);

// Completion modal handlers
tryAgainBtn.onclick = ()=>{ 
  completionModal.classList.add('hidden'); 
  reset(); 
  // Timer will start when first note is pressed
  if(state.mode==='mic') startMic(); else startMIDI();
};
backToMenuBtn.onclick = ()=>{ 
  completionModal.classList.add('hidden'); 
  stopInputs(); 
  reset(); 
  swap(play, songSelection); 
};

function onSongChange(e){
  // Removed - no longer needed with button-based selection
}

function pick(key,val,ids,e){
  state[key]=val; ids.forEach(id=>el(id).classList.remove('active')); e.target.classList.add('active');
}

function swap(hide,show){ hide.classList.add('hidden'); show.classList.remove('hidden'); }

function reset(){
  state.idx=0; state.finished=false; state.startTime=null; state.elapsed=0; state.timerStarted=false;
  
  // Reset strict mode octave range to default when starting a new song
  state.strictOctaveRange = [3, 5]; // Default 3-octave range
  
  feedback.textContent = '';
  renderTimeline();
  renderKeyboard();
  renderPrompt();
  placeStar();
  updateTimes();
}

async function startGameWithSong(songKey) {
  state.songKey = songKey;
  const song = SONGS[songKey];
  songTitleLbl.textContent = song.title;
  
  // Unlock audio context on user interaction for iOS/iPad
  if (!audioContextUnlocked) {
    await unlockAudioContext();
  }
  
  // Try to load MIDI file first, fall back to hardcoded notes
  if (song.midiFile) {
    loadBuiltInMIDI(song.midiFile, songKey);
  } else {
    state.queue = song.notes.map(toObj);
    startGame();
  }
}

async function loadBuiltInMIDI(midiPath, songKey) {
  try {
    console.log(`Loading MIDI file: ${midiPath} for song: ${songKey}`);
    
    const response = await fetch(midiPath);
    if (response.ok) {
      console.log(`Successfully loaded MIDI file for ${songKey}`);
      
      // Parse the MIDI file using existing parser
      const buffer = await response.arrayBuffer();
      const seq = await parseMIDIBuffer(buffer);
      
      if (!seq || !seq.length) {
        throw new Error('No notes found in MIDI file');
      }
      
      // Process the sequence and start the game
      state.queue = postProcessSequence(seq);
      console.log(`Parsed ${seq.length} notes from MIDI file for ${songKey}`);
      startGame();
    } else {
      throw new Error(`Failed to fetch MIDI file: ${response.status}`);
    }
  } catch (error) {
    console.log(`MIDI loading failed for ${songKey}, using hardcoded notes:`, error);
    state.queue = SONGS[songKey].notes.map(toObj);
    startGame();
  }
}

function startGame(){
  if(!state.name) state.name = el('name').value.trim();
  modeLbl.textContent = 'MIDI';
  reset();
  swap(songSelection, play);
  // Timer will start when first note is pressed
  // Always use MIDI mode with audio enabled
  startMIDI();
  // Removed guide auto-play functionality
}

// ----- Timeline & Prompt -----
function renderTimeline(){
  timeline.innerHTML='';
  const next = state.queue.slice(state.idx, state.idx+8);
  for(const n of next){
    const div = document.createElement('div');
    div.className='noteBlock';
    const color = COLORS[n.stepWhite]||'#94a3b8';
    div.style.background = color;
    div.textContent = (COLOR_NAME[n.stepWhite]||n.stepWhite);
    timeline.appendChild(div);
  }
}
function renderPrompt(){
  const exp = state.expected();
  if(!exp){ prompt.textContent = state.finished ? `All done${state.name?`, ${state.name}`:''}!` : ''; return; }
  const color = COLOR_NAME[exp.stepWhite];
  prompt.textContent = `Press: ${toLabel(exp, state.difficulty==='strict' || state.difficulty==='medium')} (${color})`;
  renderKeyboard(exp);
}

// ----- Keyboard -----
function buildKey(step, octave, active, isBlack = false){
  const d = document.createElement('div');
  d.className = isBlack ? 'black' : 'white';
  
  if(active && active.stepWhite === step.replace('#','') && (state.difficulty==='easy' || active.octave===octave)){
    if(isBlack) {
      // For black keys in strict mode, use a bright highlight color
      if(state.difficulty === 'strict' && active.step.includes('#')) {
        d.style.background = '#FF6B6B'; // Bright red for black key activation
        d.style.border = '3px solid #FF0000';
      } else {
        d.style.background = '#4b5563'; // Lighter black when active
      }
    } else {
      d.style.background = COLORS[step];
    }
  } else if(state.difficulty === 'strict' && active && active.step === step && active.octave === octave) {
    // Exact match for strict mode including black keys
    if(isBlack) {
      d.style.background = '#FF6B6B'; // Bright red for expected black keys
      d.style.border = '3px solid #FF0000';
    } else {
      d.style.background = COLORS[step];
    }
  }
  
  // Add click handler for direct key interaction
  d.style.cursor = 'pointer';
  d.addEventListener('click', async () => {
    // Unlock audio context on first interaction for iOS/iPad
    if (!audioContextUnlocked) {
      await unlockAudioContext();
    }
    
    // Always play the sound for the clicked key (like a real piano)
    await playNoteTone(step, octave);
    
    const noteStep = step.replace('#', '');
    const noteIndex = STEPS.indexOf(step);
    const midiNote = (octave + 1) * 12 + noteIndex;
    await handleIncomingMidi(midiNote);
  });
  
  const l = document.createElement('div'); 
  l.className='lbl'; 
  l.textContent = step+(state.difficulty==='strict' || state.difficulty==='medium'?octave:'');
  
  // Make black key labels more visible in strict mode
  if(isBlack && state.difficulty === 'strict') {
    l.style.color = '#fff';
    l.style.fontWeight = 'bold';
    l.style.textShadow = '1px 1px 2px rgba(0,0,0,0.8)';
  }
  
  d.appendChild(l);
  return d;
}

function buildOctaveKeys(octave, active) {
  const container = document.createElement('div');
  container.style.position = 'relative';
  container.style.display = 'flex';
  container.style.gap = '6px';
  container.style.width = '100%';
  
  // Add white keys
  for(const w of WHITE) { 
    container.appendChild(buildKey(w, octave, active)); 
  }
  
  // Add black keys positioned between white keys
  // Use percentage-based positioning that works with flexbox layout
  const blackPositions = [
    { leftPercent: 'calc(14.28% - 14px)', step: 'C#' }, // Between C and D
    { leftPercent: 'calc(28.56% - 14px)', step: 'D#' }, // Between D and E  
    { leftPercent: 'calc(57.12% - 14px)', step: 'F#' }, // Between F and G
    { leftPercent: 'calc(71.4% - 14px)', step: 'G#' },  // Between G and A
    { leftPercent: 'calc(85.68% - 14px)', step: 'A#' }  // Between A and B
  ];
  
  blackPositions.forEach(({ leftPercent, step }) => {
    const blackKey = buildKey(step, octave, active, true);
    blackKey.style.left = leftPercent;
    container.appendChild(blackKey);
  });
  
  return container;
}

function songRange(){
  let low = Math.min(...state.queue.map(n=>n.octave));
  let high = Math.max(...state.queue.map(n=>n.octave));
  low = Math.max(1, isFinite(low)?low:4); high = Math.min(7, isFinite(high)?high:4);
  return [low, high];
}

function renderKeyboard(active){
  kbd.innerHTML='';
  if(state.difficulty==='easy'){
    kbd.appendChild(buildOctaveKeys(4, active));
  } else if(state.difficulty==='medium'){
    // Medium: adaptive 3-octave display based on song range
    let [songLow, songHigh] = songRange();
    let low = 3, high = 5; // default to 3-5
    
    // If song goes above octave 5, shift the range up
    if (songHigh > 5) {
      high = Math.min(7, songHigh);
      low = Math.max(1, high - 2);
    }
    // If song goes below octave 3, shift the range down  
    else if (songLow < 3) {
      low = Math.max(1, songLow);
      high = Math.min(7, low + 2);
    }
    
    for(let o = low; o <= high; o++){ 
      kbd.appendChild(buildOctaveKeys(o, active));
    }
  } else {
    // Strict mode: adaptive 3-octave display that only updates when notes go outside current view
    updateStrictOctaveRange(active);
    const [low, high] = state.strictOctaveRange;
    
    for(let o = low; o <= high; o++){ 
      kbd.appendChild(buildOctaveKeys(o, active));
    }
  }
}

function updateStrictOctaveRange(expectedNote) {
  if (!expectedNote) return;
  
  const [currentLow, currentHigh] = state.strictOctaveRange;
  const targetOctave = expectedNote.octave;
  
  // Check if the target note is outside the current displayed range
  if (targetOctave < currentLow || targetOctave > currentHigh) {
    // Calculate new range centered around the target note
    let newLow = targetOctave - 1; // Put target in middle octave
    let newHigh = targetOctave + 1;
    
    // Clamp to valid octave range (1-7)
    if (newLow < 1) {
      newLow = 1;
      newHigh = Math.min(7, newLow + 2);
    } else if (newHigh > 7) {
      newHigh = 7;
      newLow = Math.max(1, newHigh - 2);
    }
    
    // Update the range only if it actually changed
    if (newLow !== currentLow || newHigh !== currentHigh) {
      state.strictOctaveRange = [newLow, newHigh];
    }
  }
}

// ----- Enhanced Animation System (Star for other songs, Character animations for each song) -----
function placeStar(){
  const isMarySong = state.songKey === 'mary' || state.songKey === 'maryEasy';
  const isLetItGoSong = state.songKey === 'letitgo';
  const isUploadedSong = state.songKey === 'uploaded';
  
  // New songs detection
  const isOldMacdonaldSong = state.songKey === 'oldMacdonald' || state.songKey === 'oldMacdonaldEasy';
  const isWheelsOnBusSong = state.songKey === 'wheelsOnBus' || state.songKey === 'wheelsOnBusEasy';
  const isBabySharkSong = state.songKey === 'babyShark' || state.songKey === 'babySharkEasy';
  const isHumptyDumptySong = state.songKey === 'humptyDumpty' || state.songKey === 'humptyDumptyEasy';
  const isBaaBlackSheepSong = state.songKey === 'baaBlackSheep' || state.songKey === 'baaBlackSheepEasy';
  const isItsySpiderSong = state.songKey === 'itsySpider' || state.songKey === 'itsySpiderEasy';
  const isRowBoatSong = state.songKey === 'rowBoat' || state.songKey === 'rowBoatEasy';
  
  const scene = document.getElementById('scene');
  const playSection = document.getElementById('play');
  
  // Handle uploaded song layout
  if (isUploadedSong) {
    playSection.classList.add('uploaded-layout');
  } else {
    playSection.classList.remove('uploaded-layout');
  }
  
  // Set appropriate background
  scene.className = 'scene';
  if (isUploadedSong) {
    // For uploaded songs, no background image - just basic scene
  } else if(isMarySong) {
    scene.classList.add('mary-background');
  } else if(isLetItGoSong) {
    scene.classList.add('letitgo-background');
  } else if(isOldMacdonaldSong) {
    scene.classList.add('oldmacdonald-background');
  } else if(isWheelsOnBusSong) {
    scene.classList.add('wheelsonbus-background');
  } else if(isBabySharkSong) {
    scene.classList.add('babyshark-background');
  } else if(isHumptyDumptySong) {
    scene.classList.add('humptydumpty-background');
  } else if(isBaaBlackSheepSong) {
    scene.classList.add('baablacksheep-background');
  } else if(isItsySpiderSong) {
    scene.classList.add('itsyspider-background');
  } else if(isRowBoatSong) {
    scene.classList.add('rowboat-background');
  } else {
    scene.classList.add('twinkle-background');
  }
  
  // Hide all characters first
  star.style.display = 'none';
  document.getElementById('starEffect').style.display = 'none';
  lamb.style.display = 'none';
  elsa.style.display = 'none';
  farmer.style.display = 'none';
  bus.style.display = 'none';
  shark.style.display = 'none';
  humpty.style.display = 'none';
  blacksheep.style.display = 'none';
  spider.style.display = 'none';
  boat.style.display = 'none';
  
  // Show appropriate character and animation
  if(isMarySong) {
    lamb.style.display = 'block';
    placeLamb();
  } else if(isLetItGoSong) {
    elsa.style.display = 'block';
    placeElsa();
  } else if(isOldMacdonaldSong) {
    farmer.style.display = 'block';
    placeFarmer();
  } else if(isWheelsOnBusSong) {
    bus.style.display = 'block';
    placeBus();
  } else if(isBabySharkSong) {
    shark.style.display = 'block';
    placeShark();
  } else if(isHumptyDumptySong) {
    humpty.style.display = 'block';
    placeHumpty();
  } else if(isBaaBlackSheepSong) {
    blacksheep.style.display = 'block';
    placeBlackSheep();
  } else if(isItsySpiderSong) {
    spider.style.display = 'block';
    placeSpider();
  } else if(isRowBoatSong) {
    boat.style.display = 'block';
    placeBoat();
  } else {
    star.style.display = 'block';
    placeStarForTwinkle();
  }
}

function placeStarForTwinkle(){
  const total = state.queue.length || 1;
  const progress = Math.min(state.idx/total,1);
  
  // Star starts small in house window, grows to 1/4 background size at middle,
  // then shrinks back to window size, ending at top
  let scale, y;
  
  if (progress <= 0.5) {
    // First half: grow from small (house window size) to big (1/4 background)
    scale = 0.3 + (progress * 2) * 0.7; // 0.3 to 1.0
    // Move from bottom house area toward middle
    y = 180 - (progress * 2) * 120; // From 180 to 60
  } else {
    // Second half: shrink back down and move to top
    const secondHalf = (progress - 0.5) * 2; // 0 to 1
    scale = 1.0 - secondHalf * 0.7; // 1.0 to 0.3
    // Move from middle to top
    y = 60 - secondHalf * 80; // From 60 to -20 (top)
  }
  
  // Remove jumping class to reset animation
  star.classList.remove('jumping');
  
  // Set position and scale
  star.style.transform = `translateX(-50%) translateY(${y}px) scale(${scale})`;
  
  // Add jumping animation when moving to next note (but not on first note)
  if(state.idx > 0 && state.idx < state.queue.length) {
    setTimeout(() => star.classList.add('jumping'), 50);
    setTimeout(() => star.classList.remove('jumping'), 650);
  }
  
  if(state.finished){ 
    // Show star effect at the top and hide the star
    star.style.display = 'none';
    const starEffect = document.getElementById('starEffect');
    starEffect.style.display = 'block';
    starEffect.style.opacity = '1';
    
    // Add twinkling to the effect
    starEffect.classList.add('twinkle');
  } else { 
    // Make sure star effect is hidden during gameplay
    document.getElementById('starEffect').style.display = 'none';
    star.classList.remove('twinkle'); 
    star.classList.remove('small'); 
  }
}

function placeLamb(){
  const total = state.queue.length || 1;
  const progress = Math.min(state.idx/total,1);
  
  // Move lamb across the scene (Mary is now part of background)
  lamb.style.left = `calc(${progress * 100}% * 0.8)`; // Can use more space now
  
  // Add jumping animation when moving to next note (but not on first note)
  if(state.idx > 0 && state.idx < state.queue.length) {
    lamb.style.transform = 'scale(1.1) translateY(-10px)';
    setTimeout(() => {
      lamb.style.transform = 'scale(1) translateY(0px)';
    }, 300);
  }
  
  // When finished, lamb reaches right side
  if(state.finished){ 
    lamb.style.left = 'calc(100% - 80px)'; // Position at right side
  }
}

function placeFarmer(){
  const total = state.queue.length || 1;
  const progress = Math.min(state.idx/total,1);
  
  // Move farmer with tractor across the farm
  farmer.style.left = `calc(${progress * 100}% * 0.85)`;
  
  // Add bounce animation when moving to next note
  if(state.idx > 0 && state.idx < state.queue.length) {
    farmer.style.transform = 'scale(1.1) translateY(-5px)';
    setTimeout(() => {
      farmer.style.transform = 'scale(1) translateY(0px)';
    }, 300);
  }
  
  if(state.finished){ 
    farmer.style.left = 'calc(100% - 100px)';
  }
}

function placeBus(){
  const total = state.queue.length || 1;
  const progress = Math.min(state.idx/total,1);
  
  // Move bus through the city
  bus.style.left = `calc(${progress * 100}% * 0.8)`;
  
  // Add driving animation
  if(state.idx > 0 && state.idx < state.queue.length) {
    bus.style.transform = 'scale(1.05) translateY(-3px)';
    setTimeout(() => {
      bus.style.transform = 'scale(1) translateY(0px)';
    }, 400);
  }
  
  if(state.finished){ 
    bus.style.left = 'calc(100% - 120px)';
  }
}

function placeShark(){
  const total = state.queue.length || 1;
  const progress = Math.min(state.idx/total,1);
  
  // Move shark through the ocean
  shark.style.left = `calc(${progress * 100}% * 0.85)`;
  
  // Add swimming animation
  if(state.idx > 0 && state.idx < state.queue.length) {
    shark.style.transform = 'translateY(-8px) rotate(5deg)';
    setTimeout(() => {
      shark.style.transform = 'translateY(0px) rotate(0deg)';
    }, 400);
  }
  
  if(state.finished){ 
    shark.style.left = 'calc(100% - 100px)';
  }
}

function placeHumpty(){
  const total = state.queue.length || 1;
  const progress = Math.min(state.idx/total,1);
  
  // Humpty sits on wall and falls at the end
  if(state.finished) {
    // Fall animation
    humpty.style.bottom = '0px';
    humpty.style.transform = 'rotate(90deg) scale(0.8)';
  } else {
    // Sitting on wall, slight wobble with each note
    humpty.style.bottom = '80px';
    if(state.idx > 0 && state.idx < state.queue.length) {
      humpty.style.transform = 'rotate(5deg) scale(1.1)';
      setTimeout(() => {
        humpty.style.transform = 'rotate(0deg) scale(1)';
      }, 300);
    }
  }
}

function placeBlackSheep(){
  const total = state.queue.length || 1;
  const progress = Math.min(state.idx/total,1);
  
  // Move black sheep across pastoral scene
  blacksheep.style.left = `calc(${progress * 100}% * 0.8)`;
  
  // Add knitting animation (gentle bounce)
  if(state.idx > 0 && state.idx < state.queue.length) {
    blacksheep.style.transform = 'scale(1.1) translateY(-5px)';
    setTimeout(() => {
      blacksheep.style.transform = 'scale(1) translateY(0px)';
    }, 400);
  }
  
  if(state.finished){ 
    blacksheep.style.left = 'calc(100% - 90px)';
  }
}

function placeSpider(){
  const total = state.queue.length || 1;
  const progress = Math.min(state.idx/total,1);
  
  // Spider climbs up the spout (moves up and right)
  const verticalProgress = progress * 180; // Climb up 180px
  const horizontalProgress = progress * 60; // Move right 60px
  
  spider.style.bottom = `${verticalProgress}px`;
  spider.style.left = `${20 + horizontalProgress}px`;
  
  // Add climbing animation
  if(state.idx > 0 && state.idx < state.queue.length) {
    spider.style.transform = 'scale(1.2) rotate(10deg)';
    setTimeout(() => {
      spider.style.transform = 'scale(1) rotate(0deg)';
    }, 300);
  }
  
  if(state.finished){ 
    spider.style.bottom = '200px';
    spider.style.left = '80px';
  }
}

function placeBoat(){
  const total = state.queue.length || 1;
  const progress = Math.min(state.idx/total,1);
  
  // Move boat around the lake (circular motion)
  const angle = progress * Math.PI * 2; // Full circle
  const radius = 80;
  const centerX = 120;
  const centerY = 80;
  
  const x = centerX + Math.cos(angle) * radius;
  const y = centerY + Math.sin(angle) * radius * 0.3; // Flatten the circle
  
  boat.style.left = `${Math.max(0, x)}px`;
  boat.style.bottom = `${Math.max(20, y)}px`;
  
  // Add rowing animation
  if(state.idx > 0 && state.idx < state.queue.length) {
    boat.style.transform = 'scale(1.1) rotate(5deg)';
    setTimeout(() => {
      boat.style.transform = 'scale(1) rotate(0deg)';
    }, 400);
  }
}

function placeElsa(){
  const total = state.queue.length || 1;
  const progress = Math.min(state.idx/total,1);
  
  // Move Elsa across the snowy scene, building her ice fortress
  elsa.style.left = `calc(${progress * 100}% * 0.7)`; // Move across scene
  
  // Add some sparkle effects when notes are played
  if(state.idx > 0 && state.idx < state.queue.length) {
    // Add a simple glow effect
    elsa.style.filter = 'drop-shadow(0 0 10px #87CEEB)';
    setTimeout(() => {
      elsa.style.filter = 'none';
    }, 500);
  }
  
  // When finished, Elsa reaches her ice castle
  if(state.finished){ 
    elsa.style.left = 'calc(100% - 100px)'; // Position at ice fortress
    elsa.style.filter = 'drop-shadow(0 0 15px #87CEEB)'; // Final magical glow
  }
}

// ----- Timer & session best/last -----
let rafId=null; function startTimer(){
  cancelAnimationFrame(rafId);
  const start = performance.now(); state.startTime=start;
  const tick = (t)=>{ state.elapsed = Math.round((t-start)/1000); timeLbl.textContent = state.elapsed+'s'; rafId=requestAnimationFrame(tick); };
  rafId=requestAnimationFrame(tick);
}
function stopTimerAndRecord(){
  cancelAnimationFrame(rafId);
  const secs = state.elapsed;
  const key = state.songKey;
  state.lastTimes[key] = secs;
  if(!state.bestTimes[key] || secs < state.bestTimes[key]) state.bestTimes[key] = secs;
  updateTimes();
}
function updateTimes(){
  const key=state.songKey;
  bestLbl.textContent = state.bestTimes[key] ? `${state.bestTimes[key]}s` : '‚Äî';
  lastLbl.textContent = state.lastTimes[key] ? `${state.lastTimes[key]}s` : '‚Äî';
}

// ----- Input Handling (MIDI + Mic) -----
let midiAccess=null; let midiHandler=null; let stopMicFn=null; let midiDeviceRange = { min: 21, max: 108 }; // Default 88-key piano range (A0 to C8)

async function startMIDI(){
  stopInputs();
  try{
    midiAccess = await navigator.requestMIDIAccess();
    for(const input of midiAccess.inputs.values()){
      input.addEventListener('midimessage', midiHandler = async (e)=>{
        const [status, note, vel] = e.data; const on = (status & 0xf0)===0x90 && vel>0; if(!on) return;
        detectMIDIDeviceRange(note);
        await handleIncomingMidi(note);
      });
    }
  }catch(e){ alert('Web MIDI not supported in this browser. Try Chrome/Edge or use Mic mode.'); }
}

function detectMIDIDeviceRange(note) {
  // Expand the detected range based on incoming notes
  if (note < midiDeviceRange.min) {
    midiDeviceRange.min = note;
  }
  if (note > midiDeviceRange.max) {
    midiDeviceRange.max = note;
  }
  
  // Re-render keyboard if in strict mode to adapt to detected device size
  if (state.difficulty === 'strict') {
    renderKeyboard(state.expected());
  }
}

function getMIDIDeviceOctaveRange() {
  const minOctave = Math.max(1, Math.floor((midiDeviceRange.min - 12) / 12));
  const maxOctave = Math.min(7, Math.floor((midiDeviceRange.max - 12) / 12));
  return [minOctave, maxOctave];
}
function stopMIDI(){ if(!midiAccess) return; for(const input of midiAccess.inputs.values()){ if(midiHandler) input.removeEventListener('midimessage', midiHandler);} midiAccess=null; }

async function startMic(){
  stopInputs();
  try{
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    const ctx = new (window.AudioContext||window.webkitAudioContext)();
    const src = ctx.createMediaStreamSource(stream);
    const analyser = ctx.createAnalyser(); 
    analyser.fftSize = 4096; // Increased for better frequency resolution
    analyser.smoothingTimeConstant = 0.8; // Smoothing for stability
    src.connect(analyser);
    const buf = new Float32Array(analyser.fftSize);
    let running = true;
    let lastMicNoteTime = 0;
    const MIC_DEBOUNCE_MS = 150; // Shorter debounce for microphone to feel responsive
    
    const loop = async () => {
      if(!running) return;
      analyser.getFloatTimeDomainData(buf);
      const f = autoCorrelate(buf, ctx.sampleRate);
      if(f > 0) {
        const now = Date.now();
        // Additional debouncing specifically for microphone input
        if (now - lastMicNoteTime >= MIC_DEBOUNCE_MS) {
          const midi = Math.round(69 + 12 * Math.log2(f / 440));
          // Only process notes in reasonable piano range
          if (midi >= 21 && midi <= 108) {
            await handleIncomingMidi(midi, true);
            lastMicNoteTime = now;
          }
        }
      }
      requestAnimationFrame(loop);
    };
    loop();
    stopMicFn=()=>{ running=false; stream.getTracks().forEach(t=>t.stop()); ctx.close(); };
  }catch(e){ 
    console.log('Microphone access failed, enabling keyboard click mode');
    feedback.textContent = 'Microphone unavailable - click piano keys to play! üéπ';
  }
}
function stopMic(){ if(stopMicFn){ stopMicFn(); stopMicFn=null; } }
function stopInputs(){ stopMIDI(); stopMic(); }

function autoCorrelate(buf, sr){
  // Improved autocorrelation for better pitch detection stability
  let sum = 0;
  for(let i = 0; i < buf.length; i++) sum += buf[i] * buf[i];
  const rms = Math.sqrt(sum / buf.length);
  
  // Increased threshold for better noise rejection
  if(rms < 0.02) return -1;
  
  const SIZE = buf.length;
  const MAX = Math.floor(SIZE / 2);
  let best = -1, bestCorr = 0;
  let last = 1;
  
  // Look for correlation peaks
  for(let off = 2; off < MAX; off++) {
    let corr = 0;
    for(let i = 0; i < MAX; i++) {
      corr += Math.abs(buf[i] - buf[i + off]);
    }
    corr = 1 - corr / MAX;
    
    // Improved threshold and peak detection
    if(corr > 0.92 && corr > last) {
      bestCorr = corr;
      best = off;
    }
    last = corr;
  }
  
  // Return frequency only if correlation is strong enough
  if(bestCorr > 0.92) return sr / best;
  return -1;
}

// ----- Simple Audio Tone System -----
let audioContext = null;
let audioContextUnlocked = false;

function initAudioContext() {
  if (!audioContext && state.audioEnabled) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  return audioContext;
}

// Function to unlock audio context on iOS/iPad - must be called from user interaction
async function unlockAudioContext() {
  if (audioContextUnlocked) return true;
  
  const ctx = initAudioContext();
  if (!ctx) return false;
  
  try {
    // Create a silent sound to unlock the audio context on iOS
    if (ctx.state === 'suspended') {
      await ctx.resume();
    }
    
    // Play a brief silent sound to fully unlock on iOS
    const oscillator = ctx.createOscillator();
    const gainNode = ctx.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(ctx.destination);
    
    oscillator.frequency.setValueAtTime(440, ctx.currentTime);
    oscillator.type = 'sine';
    gainNode.gain.setValueAtTime(0, ctx.currentTime); // Silent
    
    oscillator.start(ctx.currentTime);
    oscillator.stop(ctx.currentTime + 0.01);
    
    audioContextUnlocked = true;
    return true;
  } catch (error) {
    console.warn('Failed to unlock audio context:', error);
    return false;
  }
}

async function playNoteTone(step, octave) {
  if (!state.audioEnabled) return;
  
  const ctx = initAudioContext();
  if (!ctx) return;
  
  // Ensure audio context is unlocked on iOS/iPad
  if (!audioContextUnlocked) {
    await unlockAudioContext();
  }
  
  // Resume audio context if suspended (browser policy)
  if (ctx.state === 'suspended') {
    try {
      await ctx.resume();
    } catch (error) {
      console.warn('Failed to resume audio context:', error);
      return;
    }
  }
  
  // Calculate frequency for any note including sharps/flats
  // Using A4 = 440Hz as reference and equal temperament
  const noteToSemitone = {
    'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5,
    'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11
  };
  
  const semitone = noteToSemitone[step];
  if (semitone === undefined) return;
  
  // Calculate frequency using A4 = 440Hz as reference
  // Formula: f = 440 * 2^((n-69)/12) where n is MIDI note number
  const midiNote = (octave + 1) * 12 + semitone;
  const frequency = 440 * Math.pow(2, (midiNote - 69) / 12);
  
  // Create oscillator for the tone
  const oscillator = ctx.createOscillator();
  const gainNode = ctx.createGain();
  
  oscillator.connect(gainNode);
  gainNode.connect(ctx.destination);
  
  oscillator.frequency.setValueAtTime(frequency, ctx.currentTime);
  oscillator.type = 'sine';
  
  // Envelope: quick attack, sustain, quick decay
  gainNode.gain.setValueAtTime(0, ctx.currentTime);
  gainNode.gain.linearRampToValueAtTime(0.3, ctx.currentTime + 0.01);
  gainNode.gain.linearRampToValueAtTime(0.1, ctx.currentTime + 0.3);
  gainNode.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.5);
  
  oscillator.start(ctx.currentTime);
  oscillator.stop(ctx.currentTime + 0.5);
}

// ----- Correctness Logic -----
let lastNoteTime = 0;
const NOTE_DEBOUNCE_MS = 250; // Minimum time between notes to prevent accidental double notes

async function handleIncomingMidi(midi, fromMicrophone = false){
  const exp = state.expected(); if(!exp) return;
  
  // Debouncing to prevent accidental double notes
  const now = Date.now();
  if (now - lastNoteTime < NOTE_DEBOUNCE_MS) {
    return; // Ignore this note - too soon after the last one
  }
  lastNoteTime = now;
  
  const got = fromMidi(midi);
  if(state.difficulty==='easy'){
    if(got.stepWhite===exp.stepWhite){ await onCorrect(exp, 4); }
    else { onWrong(`${sayWrong()}, ${state.name?state.name+' ':''}try again!`); }
  } else if(state.difficulty==='medium'){
    // Medium: ignore sharps/flats but require correct octave
    if(got.stepWhite===exp.stepWhite && got.octave===exp.octave){ await onCorrect(exp, got.octave); }
    else if(got.stepWhite===exp.stepWhite){ onWrong(`${dir(exp.octave, got.octave)}, ${state.name?state.name+' ':''}try again!`); }
    else { onWrong(`${sayWrong()}, ${state.name?state.name+' ':''}try again!`); }
  } else {
    if(got.stepWhite===exp.stepWhite && got.octave===exp.octave){ await onCorrect(exp, got.octave); }
    else if(got.stepWhite===exp.stepWhite){ onWrong(`${dir(exp.octave, got.octave)}, ${state.name?state.name+' ':''}try again!`); }
    else { onWrong(`${sayWrong()}, ${state.name?state.name+' ':''}try again!`); }
  }
}

async function onCorrect(expectedNote, octave){
  // Start timer on first note press
  if(!state.timerStarted) {
    startTimer();
    state.timerStarted = true;
  }
  
  // Play the original MIDI note sound (preserving sharps/flats and octave) instead of the simplified stepWhite
  const soundOctave = expectedNote.originalOctave || expectedNote.octave;
  await playNoteTone(expectedNote.originalStep || expectedNote.step, soundOctave);
  
  state.idx++; 
  
  // Fun feedback messages for children
  const encouragements = [
    "Awesome! üéâ", "Great job! ‚≠ê", "Fantastic! üåü", "Well done! üéµ", 
    "Perfect! üéπ", "Amazing! üöÄ", "Brilliant! ‚ú®", "Excellent! üèÜ"
  ];
  const randomEncouragement = encouragements[Math.floor(Math.random() * encouragements.length)];
  feedback.textContent = `${randomEncouragement}${state.name ? ` ${state.name}!` : ''}`;
  
  if(state.idx>=state.queue.length){
    state.finished=true; 
    renderPrompt(); 
    renderTimeline(); 
    placeStar(); 
    stopTimerAndRecord(); 
    showCompletionPopup();
    return;
  }
  renderPrompt(); renderTimeline(); placeStar();
  // Removed guide playback
}

function showCompletionPopup() {
  const userTime = state.elapsed;
  const targetTime = getSongTargetTime(state.songKey);
  
  completionTimeDisplay.textContent = `${userTime}s`;
  
  // Update comparison graph
  updateComparisonGraph(userTime, targetTime);
  
  // Show celebration message and effects
  showCelebrationEffects(userTime, targetTime);
  
  completionModal.classList.remove('hidden');
}

function getSongTargetTime(songKey) {
  // New speed goal: 3 notes per 2 seconds = 1.5 notes per second
  // So time = notes / 1.5 = notes * 2/3
  const song = SONGS[songKey];
  if (song && song.notes) {
    const noteCount = song.notes.length;
    return Math.ceil(noteCount * 2 / 3); // 3 notes per 2 seconds
  }
  
  // Fallback for uploaded songs - use note count from current queue
  if (songKey === 'uploaded' && state.queue) {
    const noteCount = state.queue.length;
    return Math.ceil(noteCount * 2 / 3); // 3 notes per 2 seconds
  }
  
  return 10; // Default fallback
}

function updateComparisonGraph(userTime, targetTime) {
  const maxTime = Math.max(userTime, targetTime) * 1.2; // Add some padding
  
  // Calculate bar widths as percentages
  const targetWidth = (targetTime / maxTime) * 100;
  const userWidth = (userTime / maxTime) * 100;
  
  // Update target bar
  el('targetBar').style.width = targetWidth + '%';
  el('targetTime').textContent = targetTime + 's';
  
  // Update user bar with appropriate styling
  const userBar = el('userBar');
  userBar.style.width = userWidth + '%';
  el('userTime').textContent = userTime + 's';
  
  // Apply different styles based on performance
  userBar.className = 'graph-bar-fill user-bar';
  if (userTime <= targetTime) {
    userBar.classList.add('excellent');
  } else if (userTime <= targetTime * 1.2) {
    userBar.classList.add('better');
  }
}

function showCelebrationEffects(userTime, targetTime) {
  const celebrationEl = el('celebrationMessage');
  
  if (userTime <= targetTime) {
    // Excellent performance - under target time
    celebrationEl.textContent = 'üéä AMAZING! Under target time! üéä';
    createConfetti();
  } else if (userTime <= targetTime * 1.2) {
    // Good performance - close to target
    celebrationEl.textContent = '‚≠ê Great job! Almost perfect! ‚≠ê';
  } else if (state.lastTimes[state.songKey] && userTime < state.lastTimes[state.songKey]) {
    // Improvement from last time
    celebrationEl.textContent = 'üìà You\'re getting better! üìà';
  } else {
    // First try or needs improvement
    celebrationEl.textContent = 'üéµ Keep practicing! üéµ';
  }
}

function createConfetti() {
  const popup = document.querySelector('.completion-popup');
  const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#a55eea'];
  
  for (let i = 0; i < 30; i++) {
    setTimeout(() => {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      confetti.style.left = Math.random() * 100 + '%';
      confetti.style.top = Math.random() * 50 + '%';
      confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.animationDelay = Math.random() * 0.5 + 's';
      popup.appendChild(confetti);
      
      setTimeout(() => confetti.remove(), 2000);
    }, i * 50);
  }
}

function onWrong(msg){ 
  // Make error messages more child-friendly
  const friendlyMsg = msg.replace('Sorry, wrong note', 'Oops! Try a different note')
                        .replace('try again', 'give it another try');
  feedback.textContent = friendlyMsg; 
}

// ----- File Loading (MIDI only) -----
async function onFile(e){ 
  const f=e.target.files[0]; 
  if(!f) return; 
  const name=f.name.toLowerCase(); 
  try{
    let seq=null; 
    if(name.endsWith('.mid')||name.endsWith('.midi')) {
      seq=await parseMIDI(f); 
    } else { 
      alert('Only MIDI files (.mid/.midi) are supported for uploads.'); 
      return; 
    }
    if(!seq || !seq.length){ alert('No notes found in MIDI file.'); return; }
    state.songKey='uploaded';
    songTitleLbl.textContent = f.name.replace(/\.(mid|midi)$/i,'');
    state.queue = postProcessSequence(seq);
    // Start the game immediately after file upload
    startGame();
  } catch(err){ 
    console.error(err); 
    alert('Could not read that MIDI file. Try exporting from MuseScore or another music program.'); 
  } 
}

function postProcessSequence(seq){
  if(state.difficulty==='easy'){ 
    return seq.map(n=>({
      step:n.stepWhite, 
      stepWhite:n.stepWhite, 
      originalStep:n.step,  // Preserve original note for sound playback
      originalOctave:n.octave, // Preserve original octave for sound playback
      octave:4  // Display octave for easy mode
    })); 
  } else if(state.difficulty==='medium'){
    // Medium: ignore sharps/flats like easy mode, but keep octaves like strict mode
    return seq.map(n=>({
      step:n.stepWhite, 
      stepWhite:n.stepWhite, 
      originalStep:n.step,  // Preserve original note for sound playback
      originalOctave:n.octave, // Preserve original octave for sound playback
      octave: Math.min(7, Math.max(1, n.octave||4))
    })); 
  }
  // strict: keep sharps/flats and octave (clamp 1..7)
  return seq.map(n=>({step:n.step, stepWhite:n.stepWhite, octave: Math.min(7, Math.max(1, n.octave||4))}));
}

async function parseMIDIBuffer(buf){
  try {
    const view = new DataView(buf);
    let offset = 0;
    
    // Parse header chunk
    const headerChunk = parseChunk(view, offset);
    if (headerChunk.type !== 'MThd') {
      throw new Error('Invalid MIDI file: Missing header chunk');
    }
    
    if (headerChunk.length !== 6) {
      throw new Error('Invalid MIDI header chunk size');
    }
    
    const format = view.getUint16(offset + 8);
    const tracks = view.getUint16(offset + 10);
    const division = view.getUint16(offset + 12);
    
    offset += 8 + headerChunk.length;
    
    // Parse track chunks and collect notes
    const allNotes = [];
    
    for (let i = 0; i < tracks; i++) {
      if (offset >= view.byteLength) break;
      
      const trackChunk = parseChunk(view, offset);
      if (trackChunk.type === 'MTrk') {
        const trackNotes = parseTrack(view, offset + 8, trackChunk.length);
        allNotes.push(...trackNotes);
      }
      offset += 8 + trackChunk.length;
    }
    
    // Convert MIDI note numbers to the expected format and sort by time
    const sortedNotes = allNotes.sort((a, b) => a.time - b.time);
    const convertedNotes = sortedNotes.map(note => fromMidi(note.note));
    
    // Load the full MIDI file without truncation
    // Users want all notes from the MIDI files to be available
    console.log(`Loaded ${convertedNotes.length} notes from MIDI file without truncation`);
    
    return convertedNotes;
    
  } catch (error) {
    console.error('MIDI parsing error:', error);
    throw new Error(`Invalid MIDI file: ${error.message}`);
  }
}

async function parseMIDI(file){
  const buf = await file.arrayBuffer();
  return parseMIDIBuffer(buf);
}

// Helper function to parse MIDI chunks
function parseChunk(view, offset) {
  if (offset + 8 > view.byteLength) {
    throw new Error('Unexpected end of file while reading chunk header');
  }
  
  const type = String.fromCharCode(
    view.getUint8(offset),
    view.getUint8(offset + 1),
    view.getUint8(offset + 2),
    view.getUint8(offset + 3)
  );
  const length = view.getUint32(offset + 4);
  
  if (offset + 8 + length > view.byteLength) {
    throw new Error(`Chunk extends beyond file: type=${type}, length=${length}`);
  }
  
  return { type, length };
}

// Helper function to parse variable-length quantities
function parseVarLength(view, offset) {
  let value = 0;
  let currentOffset = offset;
  
  while (currentOffset < view.byteLength) {
    const byte = view.getUint8(currentOffset++);
    value = (value << 7) | (byte & 0x7F);
    
    if ((byte & 0x80) === 0) {
      return { value, length: currentOffset - offset };
    }
    
    if (currentOffset - offset > 4) {
      throw new Error('Variable length quantity too long');
    }
  }
  
  throw new Error('Incomplete variable length quantity');
}

// Helper function to parse a track and extract note events
function parseTrack(view, startOffset, trackLength) {
  const notes = [];
  let offset = startOffset;
  const endOffset = startOffset + trackLength;
  let currentTime = 0;
  let runningStatus = 0;
  
  while (offset < endOffset) {
    try {
      // Parse delta time
      const deltaTime = parseVarLength(view, offset);
      offset += deltaTime.length;
      currentTime += deltaTime.value;
      
      if (offset >= endOffset) break;
      
      // Parse MIDI event
      let status = view.getUint8(offset);
      
      // Handle running status
      if ((status & 0x80) === 0) {
        status = runningStatus;
      } else {
        offset++;
        runningStatus = status;
      }
      
      const eventType = status & 0xF0;
      
      if (eventType === 0x90) { // Note On
        if (offset + 1 >= endOffset) break;
        
        const note = view.getUint8(offset);
        const velocity = view.getUint8(offset + 1);
        offset += 2;
        
        // Only add notes with velocity > 0 (actual note on events)
        if (velocity > 0) {
          notes.push({ note, time: currentTime, velocity });
        }
        
      } else if (eventType === 0x80 || eventType === 0xA0 || eventType === 0xB0 || eventType === 0xE0) {
        // Note Off, Polyphonic Pressure, Control Change, Pitch Bend (2 data bytes)
        offset += 2;
      } else if (eventType === 0xC0 || eventType === 0xD0) {
        // Program Change, Channel Pressure (1 data byte)
        offset += 1;
      } else if (status === 0xFF) { // Meta event
        if (offset >= endOffset) break;
        
        const metaType = view.getUint8(offset++);
        const length = parseVarLength(view, offset);
        offset += length.length + length.value;
      } else if (status === 0xF0 || status === 0xF7) { // SysEx
        const length = parseVarLength(view, offset);
        offset += length.length + length.value;
      } else {
        // Unknown event, try to skip
        console.warn(`Unknown MIDI event: 0x${status.toString(16)}`);
        break;
      }
      
    } catch (error) {
      console.warn('Error parsing MIDI event, stopping track parse:', error);
      break;
    }
  }
  
  return notes;
}

// MusicXML parsing removed - MIDI only now

// Auto-detect MIDI devices and ensure MIDI mode
async function autoDetectMIDI() {
  try {
    if (navigator.requestMIDIAccess) {
      console.log('Checking for MIDI devices...');
      const midiAccess = await navigator.requestMIDIAccess();
      if (midiAccess.inputs.size > 0) {
        console.log('MIDI device detected');
        // Ensure MIDI mode and audio are enabled
        pick('mode', 'midi', ['modeMIDI'], {target: el('modeMIDI')});
        pick('audioEnabled', true, ['audioOn'], {target: el('audioOn')});
        console.log('MIDI mode activated with sound enabled');
      } else {
        console.log('No MIDI devices found, but MIDI mode still available');
      }
    } else {
      console.log('Web MIDI API not supported in this browser');
    }
  } catch (error) {
    console.log('MIDI initialization:', error);
    // Keep MIDI mode as default
  }
}

// Initial render
renderTimeline(); renderKeyboard(); renderPrompt(); placeStar();

// Auto-detect MIDI on page load
autoDetectMIDI();
</script>
</body>
</html>
